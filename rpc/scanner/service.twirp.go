// Code generated by protoc-gen-twirp v8.1.3, DO NOT EDIT.
// source: rpc/scanner/service.proto

package scanner

import context "context"
import fmt "fmt"
import io "io"
import ioutil "io/ioutil"
import http "net/http"
import strings "strings"

import twirp "github.com/twitchtv/twirp"

const (
	// ScannerServicePathPrefix is the path prefix for Twirp RPC calls.
	ScannerServicePathPrefix = "/twirp/trivy.rpc.scanner.ScannerService/"
)

// ScannerService is the trivy scanner service.
//
// The trivy scanner service provides RPCs for scanning, analyzing, and fetching results.
//
// The service is accessible via twirp over HTTP.
//
//go:generate protoc --twirp_out=. --go_out=. rpc/scanner/service.proto
//
//
// This is the client API for ScannerService.
//
// See rpc/scanner/service.proto for the service definition.
//
// Code generated by protoc-gen-twirp v8.1.3, DO NOT EDIT.
// source: rpc/scanner/service.proto

type ScannerService interface {
	Scan(ctx context.Context, in *ScanRequest) (*ScanResponse, error)
	Analyze(ctx context.Context, in *AnalyzeRequest) (*AnalyzeResponse, error)
	Cache(ctx context.Context, in *CacheRequest) (*CacheResponse, error)
}

type scannerServiceProtobufClient struct {
	client HTTPClient
	urls   [3]string
}

// NewScannerServiceProtobufClient creates a new protobuf client.
func NewScannerServiceProtobufClient(baseURL string, client HTTPClient) ScannerService {
	baseURL = strings.TrimRight(baseURL, "/")
	return &scannerServiceProtobufClient{
		client: client,
		urls: [3]string{
			baseURL + ScannerServicePathPrefix + "Scan",
			baseURL + ScannerServicePathPrefix + "Analyze",
			baseURL + ScannerServicePathPrefix + "Cache",
		},
	}
}

func (c *scannerServiceProtobufClient) Scan(ctx context.Context, in *ScanRequest) (*ScanResponse, error) {
	out := new(ScanResponse)
	err := doProtobufRequest(ctx, c.client, c.urls[0], in, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scannerServiceProtobufClient) Analyze(ctx context.Context, in *AnalyzeRequest) (*AnalyzeResponse, error) {
	out := new(AnalyzeResponse)
	err := doProtobufRequest(ctx, c.client, c.urls[1], in, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *scannerServiceProtobufClient) Cache(ctx context.Context, in *CacheRequest) (*CacheResponse, error) {
	out := new(CacheResponse)
	err := doProtobufRequest(ctx, c.client, c.urls[2], in, out)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func doProtobufRequest(ctx context.Context, client HTTPClient, url string, req, resp interface{}) error {
	bodyBytes, err := marshalProtobuf(req)
	if err != nil {
		return err
	}
	reqBody := bytesReader(bodyBytes)
	httpReq, err := newRequest(ctx, url, reqBody, "application/protobuf")
	if err != nil {
		return err
	}
	if err = httpDo(client, httpReq, resp); err != nil {
		return err
	}
	return nil
}

// HTTPClient is implemented by http.Client.
type HTTPClient interface {
	Do(req *http.Request) (*http.Response, error)
}

// newRequest makes an http.Request from a client, adding common headers.
func newRequest(ctx context.Context, url string, reqBody io.Reader, contentType string) (*http.Request, error) {
	req, err := http.NewRequestWithContext(ctx, "POST", url, reqBody)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", contentType)
	req.Header.Set("Accept", contentType)
	return req, nil
}

func httpDo(client HTTPClient, req *http.Request, resp interface{}) error {
	res, err := client.Do(req)
	if err != nil {
		return err
	}
	defer res.Body.Close()

	if res.StatusCode != http.StatusOK {
		if res.StatusCode >= 500 {
			return twirp.InternalErrorWith(&twirp.ErrorMeta{StatusCode: res.StatusCode}, "upstream server error")
		}
		errBytes, err := ioutil.ReadAll(res.Body)
		if err != nil {
			return err
		}
		return twirp.NewError(twirp.Unknown, string(errBytes))
	}

	respBytes, err := ioutil.ReadAll(res.Body)
	if err != nil {
		return err
	}
	if err = unmarshalProtobuf(respBytes, resp); err != nil {
		return err
	}
	return nil
}

// ServeHTTP implements http.Handler.
func (h *ScannerServiceServer) ServeHTTP(resp http.ResponseWriter, req *http.Request) {
	if req.Method != "POST" {
		resp.Header().Set("Allow", "POST")
		resp.WriteHeader(http.StatusMethodNotAllowed)
		return
	}

	if !strings.HasPrefix(req.URL.Path, ScannerServicePathPrefix) {
		resp.Header().Set("Content-Type", "text/plain")
		resp.WriteHeader(http.StatusNotFound)
		return
	}

	ctx := req.Context()
	path := req.URL.Path[len(ScannerServicePathPrefix):]

	switch path {
	case "Scan":
		h.serveScan(ctx, resp, req)
	case "Analyze":
		h.serveAnalyze(ctx, resp, req)
	case "Cache":
		h.serveCache(ctx, resp, req)
	default:
		resp.Header().Set("Content-Type", "text/plain")
		resp.WriteHeader(http.StatusBadRequest)
	}
}

// ... (rest of generated file unchanged)
